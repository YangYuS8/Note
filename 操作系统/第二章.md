# 第二章 处理器管理

## 思维导图

![image-20251221032936800](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221032936800.png)

![image-20251221231235231](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221231235231.png)

## 【可选】进程的概念

区分程序与进程：

- 程序:是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合；
- 进程(Process):是动态的，是程序的一次执行过程；

同一个程序多次执行会对应多个进程，当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”——PID(Process lD，进程ID)

## 【可选】进程的组成——PCB、程序段、数据段

操作系统将进程信息保存在一个数据结构PCB(ProcessControlBlock)中，即进程控制块：

1. 记录PID、进程所属用户ID(UID)——基本的进程描述信息，可以让操作系统区分各个进程；
2. 记录给进程分配了哪些资源(如:分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件)——可用于实现操作系统对资源的管理；
3. 记录进程的运行情况(如:CPU使用时间、磁盘使用情况、网络流量使用情况等)——可用于实现操作系统对进程的控制、调度；

> eg:同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的(都是运行着相同的QQ程序)

程序是如何运行的？

![image-20251221030625741](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221030625741.png)

程序段、数据段、PCB三部分组成了进程实体(进程映像)：

- PCB：如前面所写；
- 程序段：程序的代码(指令序列)；
- 数据段：运行过程中产生的各种数据(如:程序中定义的变量)；

PCB是给操作系统用的，程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。

引入进程实体的概念后，可把进程定义为:进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。(一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行)

注意:PCB是进程存在的唯一标志!

## 【可选】进程的特征

程序是静态的，进程是动态的，相比于程序，进程拥有以下特征:

- 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；
- 并发性：内存中有多个进程实体，各进程可并发执行；
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位；
- 异步性：各进程按各自独立的、不可预知的速度向前推进操作系统要提供“进程同步机制“来解决异步问题；
- 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成；

其中，动态性是进程最基本的特征，异步性会导致并发程序执行结果的不确定性。

## 进程的三态及其状态转换

### 进程的状态：

- 创建态：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB；
- 就绪态：当进程创建完成后，便进入“就绪态”处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行；
- 运行态：如果一个进程此时在CPU上运行，那么这个进程处于“运行态”，CPU会执行该进程对应的程序(执行指令序列)；
- 阻塞态：在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”。当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行；
- 终止态：一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU并回收内存空间等资源，最后还要回收该进程的PCB，当终止进程的工作完成之后，这个进程就彻底消失了。

![image-20251221223356813](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221223356813.png)

进程PCB中，会有一个变量 state 来表示进程的当前状态。如:1表示创建态、2表示就绪态、3表示运行态...

为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。

### 进程的状态转换

![image-20251221040851919](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221040851919.png)

注意:不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求)

## 【可选】进程的组织

链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针

![image-20251221225406188](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221225406188.png)

索引方式【了解即可】：根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针

![image-20251221230325077](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251221230325077.png)

## 【可选】进程控制【待施工】

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能

进程控制可以用“原语”实现，因为原语的执行具有“原子性”，只能一气呵成，期间不允许被打断。

> 思考:为何进程控制(状态转换)的过程要“一气呵成”?
>
> eg:假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…
>
> ![image-20251222002942650](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222002942650.png)
>
> 假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事:    
>
> 1. 将PCB2的 state 设为 1；
> 2. 将PCB2从阻塞队列放到就绪队列；
>
> 完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里。
>
> 所以如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。

可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性：

![image-20251222070002753](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222070002753.png)

CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。

这样，关中断、开中断 之间的这些指令序列就是不可被中断的，这就实现了“原子性”

### 进程控制相关的原语

进程的创建

![image-20251222071719690](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222071719690.png)

进程的终止

![image-20251222071817349](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222071817349.png)

进程的阻塞和唤醒

![image-20251222072120447](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222072120447.png)

进程的切换

![image-20251222072304209](./%E7%AC%AC%E4%BA%8C%E7%AB%A0.assets/image-20251222072304209.png)

## 内核态和用户态

- 内核态→用户态：执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权；
- 用户态→内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权；

## 特权指令和非特权指令

## 典型中断事件、中断屏蔽

## PSW

## 线程、内核级线程、用户级线程

## 进程是资源分配的基本单位、线程是调度的基本单位

## 调度算法:SJF，HRRF响应比，时间片轮转